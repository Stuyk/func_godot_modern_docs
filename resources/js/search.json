[[{"i":"#","p":["What IS FuncGodot?","FuncGodot is a plugin for Godot 4 that allows users to generate Godot scenes using the Quake MAP file format. Map files can be made in a variety of editors, the most commonly recommended one being TrenchBroom. It is a reworking and rewrite of the Qodot plugin for Godot 3 and 4."]},{"l":"It is not a framework.","p":["FuncGodot will not make your game for you. FuncGodot does not make doors, it does not make players, it does not make buttons. You make the entities and FuncGodot will instantiate them and apply the properties you gave to them in your map file and entity definitions: the rest is up to you."]},{"l":"It is not a BSP Compiler.","p":["FuncGodot does not compile maps into BSP files. It has no concept of vis, no concept of lit, no concept of bsp. It will not automatically cull faces. Godot does not work like the early BSP engines. You cannot use FuncGodot to map for Godot the same way you map for Quake. What you map is what you get. This makes it more consistent and reliable than a compiled BSP, since you get to choose what faces get culled, how your mesh is separated, and how your collision is generated."]},{"l":"FuncGodot is, at its core, an interpreter.","p":["FuncGodot is a map parser and geometry generator, utilizing entity definition resources in order to translate map files' entities and their properties into Godot nodes and packed scenes. It can be used for purposes as simple as only generating CSG geometry from the map file to purposes as complex as completing your entire level in your chosen map editor and only needing to click build in Godot. How much FuncGodot builds for you is dependent on how much work you put into defining how to build your maps. What you put in is what you get out.","Understanding this concept will hopefully put you on the right path forward to being able to use this wonderfully flexible tool to make some incredible games.","This manual assumes an intermediate to advanced level of experience with the Godot Engine and your map editor of choice. This manual will only cover them insofar as how they relate to the FuncGodot work flow."]},{"i":"#","p":["Who MADE FuncGodot?","FuncGodot was created by Hannah \"Embyr\" Crawford, Emberlynn Bland, and Tim \"RhapsodyInGeek\" Maccabe, Vera \"sinewavey\" Lux, reworked from the Godot 4 port of Qodot by Embyr, with contributions from members of the FuncGodot, Qodot, Godot, and Quake Mapping Communities.","Both plugins are based on the original Qodot for Godot 3.5 created by Josh \"Shifty\" Palmer."]}],[{"l":"Build Process"},{"l":"FuncGodotMap","p":["The build process begins and ends with the FuncGodot Map node. Clicking the Build button calls the build() function. The first task it performs is to verify the selected .map or .vmf file. If the file is verified, the Map node will then run through the 3 main steps of the build process:","Parsing","Geometry generation","Entity Assembly","Each of these steps has their own set of semi-isolated sub processes that take an input from the Map node and feed their output back to it for the Map node to perform the next step. Once each main step has completed, the Map node will emit a final build_complete signal."]}],[{"l":"Building Maps","p":["You've configured FuncGodot. You've configured your map editor. You've made your first test map of what will undoudbtedly be countless thousands. It's time to build.","When you get back into Godot, create a new scene. In that scene make your root node a base Node type. Call it whatever you'd like.","After that create a FuncGodotMap node as a child of this node.","Building the map 1","Why do we make the FuncGodot Map a child and not the root? When a FuncGodot Map builds its scene it frees all of its children, including manually placed or edited nodes. Any work you did within the FuncGodot Map's branch of your Scene Tree will be erased when you rebuild the map (and you will rebuild it). Instead, do your post build customizations as siblings to the FuncGodot Map rather than children.","Let's take a look at our FuncGodot Map's properties.","FuncGodotMap properties","Not much here. We have Local Map File and Global Map File. These point to the map file you want to build. The Global Map File will override the Local Map File. If you're working with a team and using source control it's probably best to stick with Local(res://) so you don't have to have matching drive and directory structures leading to the map files. The Global option is there partly as a potential Runtime build option.","The Map Settings property points to a FuncGodotMapSettings resource. FuncGodot uses this resource to define how your maps get built. Not all maps need to use the same Map Settings; it's possible to get clever and use different Map Settings resources on the same map file and get completely different results like referencing completely different textures or completely different entities utilizing common relative texture paths or class names.","Lastly we have some Build Flag options. You can generally leave these alone, but they can be helpful if you find yourself having unexpected problems.","Let's take a quick peek at our Map Settings.","Building the map 2","We went over most of these properties in the Textures Chapter, so we'll just go over the the ones we didn't cover: Inverse Scale Factor, Entity Fgd, UV Unwrap Texel Size, and Use Groups Hierarchy.","The Entity Fgd property should be fairly obvious; like the map editor configurations, make sure this is the master FGD that contains all of your base FGDs and entity definitions. UV Unwrap Texel Size is for lightmapping; consult the Godot documentation for more information."]},{"l":"Inverse Scale Factor","p":["One of the most impactful properties is the Inverse Scale Factor. It tells FuncGodot how big or small your map should be built. As it's an inverse scale, this means larger numbers will build smaller maps. How do you decide on the right inverse scale for your game though? To figure it out, it helps to know what you're scaling against.","In Godot, units are measured by meters. By default the modeling program Blender is as well. Quake maps however are all measured in Quake Units. Incidentally, a pixel in a map texture rendered at 100% scale on a brush face is equal to 1 Quake Unit.","How many pixels does a meter equal out to? 137? 22? The truth is that it's arbitrary; it really depends on what you want the average resolution of your game to be at. The FuncGodot Map Settings default to 32 because this puts a 1.5-2 meter tall player at a similar texture resolution to Quake. Feel free to experiment with this value to find the right scale for your game.","32x32 Quake Unit Block 1x1 Godot Unit Block","NOTE: Accounting for the Inverse Scale Factor in your class scripts will better allow you to design your entities within the map editor, i.e: using Quake Units to determine a moving platforms travel distance in your map editor and on import letting your node script translate that value into Godot Units using your Inverse Scale Factor."]},{"l":"Use Groups Hierarchy","p":["TrenchBroom has some unique features in the form of Layers and Groups(not to be confused with func_group, but also they're func_groups; they're weird). They add a convenient level of organization to the map making process.","Hammer based editors also have a similar feature called VisGroups that can also provide a similar level of organization and a tree like hierarchy to your map.","In some cases mappers may want to design their maps in such a way as too create a hierarchy for their nodes using TrenchBroom Layers and Groups or VMF VisGroups. FuncGodot offers this option using the Use Groups Hierarchy property.","Let's say you created two layers and two groups of brush entities, both groups on separate layers.","TrenchBroom screenshot depicting 2 layers named Texas and Massachusetts and 2 groups of brush entities named Richardson and Arkham.","If Use Trenchbroom Groups Hierarchy is disabled, your built FuncGodotMap scene structure will look something like this:","Scene tree showing a flat entity hierarchy","However, if you build your FuncGodotMap with Use Groups Hierarchy enabled, you'll get this instead:","Scene tree showing a multi level entity hierarchy based upon the map layers and groups","TrenchBroom Layers also have an extra omit feature that FuncGodot can take advantage of. Any TrenchBroom Layers with omit set will not be built, nor will their child groups or entities."]},{"l":"Default Map Settings","p":["Every time you instantiate a new FuncGodotMap node the map settings applied default to the resource found in the addons folder. Instead of forcing you to set the map settings to your custom one each time, FuncGodot does have a Project Setting that allows you to choose a custom Map Settings resource as your default.","FuncGodotMap buttons","Keep in mind that this only affects new FuncGodotMap nodes. Any already instantiated with the old settings will retain them unless manually changed."]},{"l":"Building","p":["You have your map file selected. You have your map settings ready. You've decided on an inverse scale factor and, if you're using TrenchBroom, you've decided whether you want a flat or multi-level scene tree hierarchy. It's time to build the map.","FuncGodotMap buttons","The Build button will build the map scene and apply all the appropriate ownership and settings to the map scene.","Go ahead and perform a Build and marvel in your master level craftsmanship.","Congratulations! You've built your first FuncGodot Map!"]}],[{"l":"Conditional Models in TrenchBroom","p":["Let's say we want to add a misc_model or prop_dynamic entity class. Wouldn't it be nice if we could change a property and have our map editor reflect that change?","TrenchBroom allows you to modify certain meta property options through the use of an entity's own properties. There is a great example of this in the TrenchBroom version of Quake's FGD file. Let's look at an example with item_health, which uses spawnflags to determine if the item becomes a Medkit, a Rotten Medkit, or a Megahealth.","We can see that the pattern is essentially property expression - model path. While this is fine done via flags, it might be better to use a choices if you have a lot of models you wish to choose from. A good template might be:","We achieve this with a dictionary property we can call model_id and by adding an element to our Meta Properties dictionary with the key model and the String value {{ model_id == 1 - path: path/to/model1.glb, model_id == 2 - path: path/to/model2.glb, model_id == 3 - path: path/to/model3.glb, path: path/to/model0.glb }}.","This doesn't affect the Godot entity that gets built. You'll still need to make your own script that handles the model swaps upon building in Godot. Should be pretty trivial to use a match statement utilizing your entity's model_id property though!"]}],[{"l":"Entity Key Value Pairs"},{"l":"What Are Key Value Pairs?","p":["Key Value Pairs are the most powerful aspect of FuncGodot. All of the Class Properties set in a FuncGodotFGDEntity definition get added to the corresponding entity placed in the map editor.","Key Value Pairs are defined in a FuncGodotFGDEntityClass resource's Class Properties dictionary. A Class Property is defined with a key String and a value of many of the Godot Variant Types(see Property Types below for a full list). The value set becomes both the default value and the Variant type the FuncGodotMap applies to that property on map build.","Additionally, you can define a property description. With the exception of Choices and Bit Flags, property descriptions are created by matching a key from Class Properties to the Class Property Descriptions dictionary and setting a String value for the description.","The result as it appears in TrenchBroom:","If you plan on using J.A.C.K. you may want to use the descriptions as proper names for the keys rather than actual descriptions. The same entity's properties as they appear in J.A.C.K.:","Once the corresponding node is generated by a FuncGodotMap, these key value pairs are then applied to the generated node's func_godot_properties dictionary. Additionally, if you add undefined key value pairs in your map editor, these too will be added to your node's func_godot_properties dictionary.","NOTE: Entity keys that are not given values will have their default values applied to the generated node's func_godot_properties dictionary."]},{"l":"Applying Key Values","p":["It's pretty easy to apply entity key value pairs to nodes generated by FuncGodot. You have one property and two methods that you can use: the Dictionary func_godot_properties, the method _func_godot_apply_properties(entity_properties: Dictionary), and the deferred method _func_godot_build_complete().","After the entity is built, FuncGodot will check if the entity contains a func_godot_properties Dictionary, and if it exists it will apply the translated key value pairs as a Dictionary to this variable. In order for the application to persist at Runtime or after closing your scene, you'll need to make sure the variable is an @export variable.","Use _func_godot_apply_properties to apply your key value pairs to your node, as they are passed through the _func_godot_properties argument in the function.","_func_godot_build_complete is a deferred call that happens after every entity has called _func_godot_apply_properties, making it safe to reference any nodes generated during _func_godot_apply_properties.","FuncGodotMap GDScript method showing application of 'func_godot_properties' and callback of '_func_godot_apply_properties' and '_func_godot_build_complete'.","You are allowed to limit yourself to only the application methods you're interested in. Mix and match these options as you see fit for your entities."]},{"l":"Property Types","p":["Array","AudioStream","AudioStream is intended as an audio file path property type in map editors. Some map editors may offer a sound picker. Returns a String on map build, using the assigned default AudioStream's resource path as the property's value.","Automatically sets up options \"No\" and \"Yes\" with values \"0\" and \"1\" respectively.","Bool","choices","Color","Color key values are represented as \"R G B\", with each value being from 0 to 255. Some map editors may offer a color picker. Alpha is always set to 1.0. If alpha requires specification, use an additional float property.","color255","decal","Dictionary","FGD Value Type","flags","Float","FuncGodot supports many of the Godot Variant types. Consult the [key values section of the FGD page on the Valve Developer Wiki]( https://developer.valvesoftware.com/wiki/FGD#key values) for more information on FGD value types.","Godot Variant Type","Int","integer","Material","material / shader","Material is intended as a texture path property type in map editors. Some map editors may offer a texture picker. J.A.C.K. utilizes the shader key word (make sure to set your FuncGodotFGDFile's target_map_editor property to JACK). Returns a String on map build, using the assigned default Material's resource path as the property's value.","NodePath","NodePath is intended as a targeting property type in map editors, similar to Quake's \"target\" property. Some map editors may have additional editor display options showing links between entities. Not utilized in every map editor. Returns a String on map build.","Notes","Object","Object is intended as a target name property type in map editors, similar to Quake's \"targetname\" property. Some map editors may have additional editor display options showing links between entities. Not utilized in every map editor. Returns a String on map build.","Returns an Int on map build to be used as a bit mask. Somewhat complicated to set up and only flexibly supported in TrenchBroom. See the Bit Flags section for more information.","Returns an Int or String on map build. Dictionaries are a special property case. See the Choices section for more information.","sound","String","StringName","target_destination","target_source","Texture2D","Texture2D is intended as a decal texture path property type in map editors. Some map editors may offer a texture picker, typically filtered to only access a decals.wad. In the map editor, the texture at the specified path will behave in a similar way to Godot's Decal node. Returns a String on map build, using the assigned default Texture2D's resource path as the property's value.","Vector2","Vector2 key values are represented as string \"X Y\". Can accept floating point values.","Vector2i","Vector2i key values are represented as string \"X Y\". Can only accept integer values.","Vector3","Vector3 key values are represented as string \"X Y Z\". Can accept floating point values.","Vector3i","Vector3i key values are represented as string \"X Y Z\". Can only accept integer values.","Vector4","Vector4 key values are represented as string \"W X Y Z\". Can accept floating point values.","Vector4i","Vector4i key values are represented as string \"W X Y Z\". Can only accept integer values."]},{"l":"Choices","p":["The choices key value type allows you to open a dropdown menu of predefined options in your map editor. They are defined in Godot by choosing a value type of dictionary, with each key being the option text and each value being the property value. Keys are always Strings, but values can be either Int or String.","Normally the default value is set in Class Properties, but for Choices we can't do this (not without a fair amount of trouble). Instead we use Class Property Descriptions to set a default value. We do this by creating an Array with 2 elements: the first element is a String serving as the description; the second element is the default choice and should be either an Int or String matching one of the option values defined in Class Properties.","Once written to the FGD you should get a something like this in your map editor:","NOTE: While Bool types always generate a choices key value type, you don't need to set them up any differently than any other property. FuncGodot will automatically format Bool types for you on FGD export."]},{"l":"Bit Flags","p":["Bit flags are the most complex key value type to set up, but offer a lot in simplifying complex comparisons and systems in your game scripts.","To set up a bit flags property, choose Array as the value's Variant type. Each element of the Array will be an Array as well, representing a single Flag. Each Flag Array is composed of 3 elements: a String serving as the Flag Description, an Int declaring the Flag's Bit Value, and an Int representing the Flag's default state.","Bit Flag properties do not utilize descriptions so there is no need to add one to the entity's Class Property Descriptions dictionary.","Once exported, you should get something like this:","Left, Trenchbroom; Right, J.A.C.K.; Not shown: NetRadiant Custom because I'm lazy, but it's pretty similar to J.A.C.K. in this regard.","Even though Godot uses 64 bit signed integers, map editors only seem to offer support for up to 24 bit flags. This is largely an artifact of the Quake engine, specifically its Quake C programming language. QuakeC doesn't have an integer type and instead used a 32 bit floating point number. The result was that only 24 bits remained to be used in bitwise operations. The Half-Life engine inherited this limitation, and subsequent Quake and Valve map editors designed their bit flag menus with this limitation in mind.","In TrenchBroom this isn't too much of a problem as you can have multiple bit flag key value pairs. Unfortunately other map editors are designed to only support one group of flags that they assume to be spawnflags, no matter what they're called in the FGD. J.A.C.K. will just overwrite spawnflags. NetRadiant Custom will throw errors if it detects flag values with matching bits and be unable to open. All key value types of flags will be compiled into the entity's Flags property and saved in the map file with the key \"spawnflags\".","If you're using another map editor other than TrenchBroom, you can still use multiple flags key value pairs or inherit them across multiple Base Classes. Just make sure each flags property applied to an entity has a unique bit value and expect FuncGodot to build it as a compiled spawnflags bitmask."]},{"l":"Build Stage Properties","p":["_phong","_phong_angle","_vertex_merge_distance","Bool","Default Key","Determines whether the FuncGodotFGDSolidClass entity performs mesh smoothing operations.","Entity Name Property","Entity Smoothing Angle Property","Entity Smoothing Property","Float","FuncGodot also has a few properties that can be used as part of the build process, all of which are customizable in the Map Settings resource. These properties are exposed by the FGD to be set in the map file and read by FuncGodot's core classes throughout the build stages. These build stage properties are:","In Quake mapping there are a number of compiler only key value pairs that can alter the way the map is built, typically preceded by an underscore. These include properties like _phong, _minlight, and _shadow.","Map Settings Property","Notes","Property used to rename nodes. The entity is renamed \"entity_\" + entity_name_property. This can be overridden by the entity definition.","Provides a snapping epsilon for vertices in a FuncGodotFGDSolidClass entity's mesh. Adjusting this value can remove instances of gaps between polygon seams.","Some of these properties have built-in support through the use of the default FuncGodotFGDBaseClass resources Phong and VertexMergeDistance.","String","The angular threshold that determines when a FuncGodotFGDSolidClass entity's mesh vertices are smoothed.","Variant Type","Vertex Merge Distance Property"]}],[{"l":"Forge Game Data","p":["FGD stands for \"Forge Game Data\", leftover from when the Half-Life 2 level editor Hammer used to be the Half-Life 1 editor Worldcraft, and before that when it was a Quake tool called Forge.","The Level Design Book","FuncGodot utilizes FuncGodotFGD Resources to act as a translation guide for the map build process. These resources are largely separated into two different types: the FuncGodotFGDFile and the FuncGodotFGDEntityClass. Think of the FGD File as a dictionary, and the FGD Entity Classes as the entries.","FuncGodot FGD Resource List."]},{"l":"FGD File Resource","p":["Some of you may only want to build map geometry with some control over collision and occlusion, and prefer to add all of your lights, actors, scripting, etc... in Godot directly. To that end there is a basic default func_godot_fgd.tres included with FuncGodot. You can find it under addons/func_godot/fgd/func_godot_fgd.tres.","func_godot_fgd.tres location.","This is the default FGD file set in the FuncGodotMapSettings resource. The basic entity definitions included with it are Worldspawn, func_geo, func_detail, func_detail_illusionary, func_illusionary, and Phong. We'll go over what each of these entity types are a little farther below.","But what if you want to add your own custom entity types? It's always best practice to create your own FGD File resource and NEVER a good idea to just modify the pre-existing default FGD File. Any time FuncGodot is updated, it will overwrite the func_godot_fgd.tres that comes with it and erase any changes you've made to that resource. While the goal is to keep the default FGD File as basic as possible, we cannot guarantee it won't be changed at some point in the future.","That said, it is possible to include the default FuncGodot FGD File into your own as a Base FGD. Create a new FuncGodotFGDFile resource and examine it in the inspector.","FuncGodotFGDFile resource properties.","The Export File property does exactly what you might think: it generates and saves your FGD file to the Map Editor Game Config Folder set by the FuncGodot Local Config. Use this whenever you need to update your FGD.","The next property, Target Map Editor, is intended to help with specific key words that aren't shared across the different map editors. Point class entities in map editors can have display models assigned to them according to their FGD definitions. Most map editors seem to use the \"studio\" key word to define the model path, but TrenchBroom instead optionally allows the \"model\" key word while also including additional display options and expressions. When set to false, FuncGodot will omit entity definition meta properties using the \"model\" key word in order to prevent errors in your chosen map editor. When exporting the FGD File through a TrenchBroom Game Config resource the setting will be overridden to true. See the Valve Developer Wiki for more information.","Fgd Name should be self evident: this will be your exported FGD's filename, minus the file extension. Best practice would be to set this to either your game's name or its acronym.","Base Fgd Files is an array of FuncGodotFGDFile resources that will be prepended to our final FGD file output. It is not necessary to export these base FGD Files; only the FGD File they are added to needs to be exported and the rest will be built by and merged into what you could consider your \"Master FGD File\".","NOTE: This is not where you would put your FuncGodotFGDBaseClass resources! Those are not the same as FuncGodotFGDFile resources and are considered entities! More information on FuncGodotFGDBaseClass found below.","To add the func_godot_fgd.tres as a base FGD file to your custom FGD file, all you need to do is locate func_godot_fgd.tres and drag and drop it onto the Base Fgd Files array in the inspector.","FuncGodotFGDFile base FGD example.","The last property is Entity Definitions. This is where you'll drop all of your custom entity resources to be built or instanced by FuncGodot. Let's take a look at what a populated one looks like by viewing the default func_godot_fgd.tres in the inspector.","FuncGodotFGDFile default FGD."]},{"l":"Entity Class Definitions","p":["In terms of how to map with the Quake Map File > FuncGodot > Godot pipeline, it's best to think of the entities in Quake design terms. That is to say, everything is an entity: the player, the enemies, the ambient sounds, the doors, the lifts, the trigger volumes, the map geometry itself... all of these should be thought of as entities.","All map editors and FuncGodot support at least 2 different kinds of entities: Solid (Brush) Entities and Point Entities. Using FuncGodotFGDSolidClass and FuncGodotFGDPointClass resources, you can generate any type of Godot node and apply any script to it.","Every entity is comprised of 2 things: Metadata and Key Value Pairs.","Metadata tells the map editor how to display your entity, things like bounding box color or display models for Point Entities, but have no effect in Godot.","Key Value Pairs on the other hand can be thought of as your entity's properties. In a map file, all entities are comprised of Key Value Pairs. Each entity will always have a classname; this classname is what FuncGodot uses to determine what node or packed scene is generated and how upon building the FuncGodotMap.","The FuncGodotMap attempts to call two methods on each entity at the end of the build process. As an added advantage of using these calls, you can guarantee that all FuncGodotMap generated nodes now exist and can reference each other."]},{"l":"Modifying Entities on Map Build","p":["FuncGodotMap GDScript method showing application of 'func_godot_properties' and callback of '_func_godot_apply_properties' and '_func_godot_build_complete'.","If you decide you want to make modifications to your generated entities on map build using any of the following methods, you'll need to make sure that your entity's script is set as a @tool script.","The first method call is to _func_godot_apply_properties(entity_properties: Dictionary). Because _func_godot_apply_properties passes the entity properties in the function, you do not need to declare a func_godot_properties dictionary in your node script; instead, just apply your properties as needed in this callback.","After every entity has called _func_godot_apply_properties, FuncGodot will cycle through all of them again and attempt to call _func_godot_build_complete() as a deferred call. Since we're calling this method deferred after every entity has already called the previous method, we can guarantee any nodes generated by our entities in _func_godot_apply_properties can be referenced during _func_godot_build_complete.","Additionally upon building, all of the entity's key value pairs will be added to the generated node's func_godot_properties Dictionary (provided that the property is set as an exported variant).","We'll examine this FuncGeo class as a demonstration of the relationships between the FuncGodotFGDBaseClass, the FuncGodotFGDSolidClass, the func_geo brush entity in the map editor, and the final generated Godot FuncGeo StaticBody3D node.","The image on the left depicts a Base Class resource that contains other base classes to accumulate Class Properties. The image on the right is a Solid Class resource containing that Base Class and defines our FuncGeo entity.","Func Base Class FuncGeo Solid Class","This is our FuncGeo entity's properties as they appear in TrenchBroom.","func_geo brush entity properties in TrenchBroom","The generated FuncGeo node's properties in the inspector. See how our Func Godot Properties Dictionary matches our Class Properties from our map editor.","Generated FuncGeo node in Godot","With FuncGodot, your entity does not necessarily need a tool script. And even if you provide it a tool script, it does not need a func_godot_properties dictionary. FuncGodot will still generate and instantiate these entities without providing any properties. However, to take full advantage of FuncGodot's power it is highly recommended that you provide your nodes with both.","See the chapters on FuncGodotFGDEntityClass resources and Entity Key Value Pairs for more information."]},{"l":"Default Entities","p":["All default FuncGodot entities, except for Phong, are FuncGodotFGDSolidClass entities. All of the SolidClass entities are very similar, mostly differing in occlusion and collision.","Phong : A FuncGodotFGDBaseClass that provides _phong and _phong_angle properties to most of the entities below. See the Wikipedia article on Phong Shading for quick primer.","VertexMergeDistance : A FuncGodotFGDBaseClass that provides a _vertex_merge_distance property to all of the entities below. This property is used in the build process to better ensure vertices between brushes get connected, to reduce instances of gaps between seams in polygons.","NOTE: Some map editors are strict about entity definition order! To stay safe, make sure that any entity classes that inherit from a base class come after that base class. This includes other base classes! Otherwise you may run into issues where properties are not properly inherited.","worldspawn : A geometry class that mimics the Worldspawn entity found in Quake and Half-Life. In the FuncGodot implementation, Worldspawn generates a single StaticBody3D with a child MeshInstance3D and multiple convex CollisionShape3D children. It also generates an OccluderInstance3D with an ArrayOccluder3D. Under normal circumstances, there can only ever be one Worldspawn entity in a map file. While there technically are ways to create multiple Worldspawn entities this manual will not explore that possibility.","func_geo : Identical to Worldspawn, with the exception being that you can (and should) create multiple func_geos. See Why Not Worldspawn? for more information.","func_detail : Almost identical to func_geo, with the exception that they do not generate OccluderInstance3D children.","func_illusionary : Geometry that has no collision. It generates a Node3D, a MeshInstance3D child, and an OccluderInstance3D child.","func_detail_illusionary : Identical to func_illusionary, except that it does not generate an OccluderInstance3D child."]}],[{"l":"Frequently Asked Questions","p":["Why are my textures blurry?! Can I do... How does FuncGodot handle source control? Why am I getting an error trying to export my Local Configuration? Why are my new entities not building? Why can't I find them in my map editor? Why are all my entities being generated as scriptless Node3Ds? Help! I manually added some nodes to my FuncGodotMap and when I hit build again they all disappeared! How do I split up my map? It only comes out as one big mesh I'm getting a lot of overdraw, why doesn't FuncGodot get rid of unseen faces? Why are my textures blurry?!","Why are my textures blurry?! Please don't skim the manual.","Can I do... Yes.","How does FuncGodot handle source control? All resources that need to access or reference global paths go through the FuncGodot Local Config settings that are local to each machine. The various tool and project paths do need to be set per machine. Additionally, the FuncGodotMap has the option for using a local path to map files.","Why am I getting an error trying to export my Local Configuration? You need to run your project at least once so that Godot can create the user:// folder. This can be any scene. After the first run, you'll be able to export your Local Config.","Why are my new entities not building? Why can't I find them in my map editor? Double check to make sure you set a Classname in the entity resource before you exported the FGD. If this doesn't exist, FuncGodot will skip adding it to the FGD file and will only generate a Node3D.","Why are all my entities being generated as scriptless Node3Ds? Make sure your FuncGodotMap node is using the correct FuncGodotMapSettings resource. The Map Settings resource determines the FGD File resource used for the map generation, and any entities it does not recognize will generate as Node3Ds.","Help! I manually added some nodes to my FuncGodotMap and when I hit build again they all disappeared! FuncGodotMap nodes will always erase every child they have when rebuilt. There's no practical way for FuncGodot to confidently differentiate what it built, what was programmatically built as a result of its build, and what was hand placed by the user. If you feel the need to manually place nodes you should do so outside of the FuncGodotMap node in order to not lose any work.","How do I split up my map? It only comes out as one big mesh You're still mapping like you're compiling for the Quake engine. You need to map like your target is the Godot Engine.","I'm getting a lot of overdraw, why doesn't FuncGodot get rid of unseen faces? You're still mapping like you're compiling for the Quake engine. You need to map like your target is the Godot Engine.","Why are my textures blurry?!..."]}],[{"l":"FuncGodot FGD Resources"},{"l":"FuncGodotFGDFile","p":["Array of FuncGodotFGDFile resources to include in FGD file output. All of the entities included with these FuncGodotFGDFile resources will be prepended to the outputted FGD file.","Array of resources that inherit from FuncGodotFGDEntityClass. This array defines the entities that will be added to the exported FGD file and the nodes that will be generated in a FuncGodotMap.","Array[Resource]","Base Fgd Files","Bool","Description","Entity Definitions","Export File","FGD","Fgd Name","FGD output filename without the extension.","FuncGodotTargetMapEditor","Level Design Book FGD Chapter Valve Developer Wiki FGD Article","Map Editor","Property","Resource file used to express a set of FuncGodotFGDEntity definitions. Can be exported as an FGD file for use with a Quake map editor. Used in conjunction with a FuncGodotMapSettings resource to generate nodes in a FuncGodotMap node.","Some map editors do not support the features found in others (ex: TrenchBroom supports the \"model\" key word while others require \"studio\", J.A.C.K. uses the \"shader\" key word while others use \"material\", etc...). If you get errors in your map editor, try changing this setting and re-exporting. This setting is overridden when the FGD is built via a game config resource.","String","Target Map Editor","Type","Used as a button to build and export the FGD file. Automatically sets to off after exporting."]},{"l":"FuncGodotFGDEntityClass","p":["Appearance properties for the map editor. Supports String entries literally. Will JSON.stringify() Dictionary entries. See the Valve Developer Wiki and TrenchBroom documentation for more information.","Array[Resource]","Array[String]","Auto Apply To Matching Node Properties","Automatically applies entity class properties to matching properties in the generated node. When using this feature, class properties need to be the correct type or you may run into errors on map build.","Base Classes","Base entity definition class. Not to be used directly, use FuncGodotFGDBaseClass, FuncGodotFGDSolidClass, or FuncGodotFGDPointClass instead.","Bool","Class Properties","Class Property Descriptions","Classname","Description","Dictionary","Entity classname. This is a required field in all entity types as it is parsed by both the map editor and by FuncGodot on map build.","Entity Definition","Entity description that appears in the map editor. Not required.","Entity does not get written to the exported FGD. Entity is only used for FuncGodotMap build process.","Func Godot Internal","FuncGodotFGDBaseClass resources to inherit Class Properties and Class Descriptions from.","Key value pair properties that will appear in the map editor. After building the FuncGodotMap in Godot, these properties will be added to a func_godot_properties Dictionary that gets applied to the generated node, as long as that node is a @tool script with an exported func_godot_properties Dictionary. See Entity Key Value Pairs for more information.","Map editor descriptions for the previously defined key value pair properties. Optional but recommended.","Meta Properties","Name Property","Node Class","Node Generation","Node Groups","Node to generate on map build. This can be a built-in Godot class, a GDScript class, or a GDExtension class. For Point Class entities that use Scene File instantiation leave this blank. There is no restriction on what Node Classes can be generated.","Optional array of node groups to add the generated node to.","Optional class property to use in naming the generated node. Overrides FuncGodotMapSettings' name_property. Naming occurs before adding to the SceneTree and applying properties. Nodes will be named \"entity_\" + name_property. An entity's name should be unique, otherwise you may run into unexpected behavior.","Property","Quake Wiki Entity Article Level Design Book: Entity Types and Settings Valve Developer Wiki FGD Article Valve Developer Wiki Entity Descriptions","String","Type"]},{"l":"FuncGodotFGDBaseClass","p":["Special inheritance class for Solid Class and Point Class entity definitions. Useful for adding shared or common properties and descriptions. Does not have any unique properties on its own but is defined separately to facilitate FGD building and lookup.","Quake Wiki Entity Article Level Design Book: Entity Types and Settings Valve Developer Wiki FGD Article"]},{"l":"FuncGodotFGDSolidClass","p":["FGD SolidClass entity definition that generates a mesh from Brush Data.","A MeshInstance3D will be generated by FuncGodotMap according to this definition's Visual Build settings. If node_class inherits CollisionObject3D then one or more CollisionShape3D nodes will be generated according to Collision Build settings.","Quake Wiki Entity Article Level Design Book: Entity Types and Settings Valve Developer Wiki FGD Article Valve Developer Wiki Entity Descriptions dumptruck_ds' Quake Mapping Entities Tutorial"]},{"l":"FuncGodotFGDPointClass","p":["A resource used to define an FGD PointClass entity. PointClass entities can use either the Node Class or the Scene File property to tell a FuncGodotMap what to generate on map build.","An optional scene file to instantiate on map build. Overrides Node Class and Script Class.","An optional Script resource to attach to the node generated on map build. Ignored if scene_file is specified.","Apply Rotation On Map Build","Apply Scale On Map Build","Bool","Build","Description","PackedScene","Property","Quake Wiki Entity Article Level Design Book: Entity Types and Settings Valve Developer Wiki FGD Article dumptruck_ds' Quake Mapping Entities Tutorial Level Design Book: Display Models for Entities Valve Developer Wiki FGD Article: Entity Description Section TrenchBroom Manual: Display Models for Entities","Scene","Scene File","Script","Script Class","Scripting","Toggles whether entity will use `scale` to determine the generated node or scene's scale. This is performed on the top level node. The property can be a float, Vector3, or Vector2. Set to false if you would like to define how the generated node is scaled yourself.","Toggles whether entity will use angles, mangle, or angle to determine rotations on FuncGodotMap build, prioritizing the key value pairs in that order. Set to false if you would like to define how the generated node is rotated yourself.","Type"]},{"l":"FuncGodotFGDModelPointClass","p":["A special type of FuncGodotFGDPointClass entity that automatically generates a special simplified, scaled, and reoriented GLB model file for the map editor display. Only supported in map editors that support GLTF or GLB.","Bool","Button","Creates a .gdignore file in the model export folder to prevent Godot importing the display models. Only needs to be generated once.","Degrees to rotate model prior to export. Different editors may handle GLTF transformations differently. If your model isn't oriented correctly, try modifying this property.","Description","Determines how the entity definition defines the display model. GENERIC: Entity definition uses the @studio key word. scale_expression is ignored. Supported by all map editors. TRENCHBROOM: Entity definition uses the @model key word. scale_expression is applied if set.","Display model export folder relative to ProjectSettings func_godot/model_point_class_save_path.","Generate GD Ignore File","Generate Size Property","Model Point Class can override the size meta property by auto-generating a value from the meshes' AABB. Proper generation requires scale_expression set to a float or Vector3. WARNING: Generated size property unlikely to align cleanly to grid!","Models Sub Folder","Property","Quake Wiki Entity Article Level Design Book: Entity Types and Settings Valve Developer Wiki FGD Article dumptruck_ds' Quake Mapping Entities Tutorial Level Design Book: Display Models for Entities Valve Developer Wiki FGD Article: Entity Description Section TrenchBroom Manual: Display Models for Entities","Rotation Offset","Scale Expression","Scale expression applied to model. Only used by TrenchBroom. If left empty, uses ProjectSettings func_godot/default_inverse_scale_factor. See the TrenchBroom Documentation for more information.","String","Target Map Editor","TargetMapEditor","Type","Vector3"]}],[{"l":"FuncGodot Geometry Generator","p":["Geometry generation class that is instantiated by a FuncGodotMap node."]},{"l":"Signals","p":["Signal","Description","declare_step","Emitted when a step in the geometry generation process is completed. It is connected to FuncGodotUtil's print_profile_info() method if the FuncGodotMap's Show Profiling Info build flag is set."]},{"l":"Methods","p":["Array[int]","Bool","Brushes","build(build_flags: int, entities: Array[EntityData])","Calculates entity origin information depending on its Solid Class Origin Type.","create_patch_mesh(data: Array[PatchData], mesh: Mesh)","Description","determine_entity_origins(entity_index: int)","Error","generate_brush_vertices(entity_index: int, brush_index: int)","generate_entity_surfaces(entity_index: int)","generate_entity_vertices(entity_index: int)","Generates vertex data for each brush in a given Solid Class entity.","Generates visual and collision shapes for a given entity. Optionally generates surface metadata, if defined by the entity's definition.","get_triangle_indices(width: int, height: int)","is_clip(face: FaceData)","is_origin(face: FaceData)","is_skip(face: FaceData)","Main Build Process","Main entrypoint for generating geometry given entities retrieved from parsing a map file. Perform entity and brush vertex generation, determines entity origins, winds and indexes each face, then generates output surfaces and collision shapes for each entity.","Method","Not yet implemented.","Patches","Performs planar intersections for each face in a single brush to populate the vertex, normal, UV and tangent arrays.","Performs UV2 unwrapping for a given entity.","Return type","Returns an integer index array for triangulation of a vertex grid with a given size width x height.","Returns whether a given face is considered only for collision shape generation only. Local method bound to the supplied Map Settings.","Returns whether a given face is considered only for entity origin calculations only. Local method bound to the supplied Map Settings.","Returns whether a given face is skipped entirely for both collision shape and visual mesh generation. Local method bound to the supplied Map Settings.","Sample a Bezier curve defined by an array of control points at a given parametric value t. While not limited to [0.0, 1.0], it is assumed to be normalized unless extrapolation is desired.","Sample a Bezier surface defined by a flat array of control points with a given width M and height N, along two parametric values U and V. Note: U and V here are not related to texture UV coordinates.","sample_bezier_curve(controls: Array[Vector3], t: float)","sample_bezier_surface(controls: Array[Vector3], width: int, height: int, u: float, v: float)","Tools","unwrap_uv2s(entity_index: int, texel_size: float)","Vector3","Void","wind_entity_faces(entity_index: int)","Winds and indexes each face's vertices in each brush of a given Solid Class entity."]}],[{"l":"FuncGodotData","p":["FuncGodot utilizes multiple custom data structures ( structs) to hold information parsed from the map file and read and modified by the other core build classes.","Each data type extends from RefCounted; therefore all data is passed by reference."]},{"l":"FuncGodot FaceData","p":["Data struct representing both a single map plane and a mesh face. Initially generated during parsing, reading plane definitions in the map file. Further modified and utilized during the geometry generation stage to populate face vertex, normal, UV, tangent, and index data."]},{"l":"Methods","p":["Method","Description","Return type","get_centroid()","Returns the centroid of all vertices in the face. Only valid when the face has at least one vertex.","Vector3","get_basis()","Returns an arbitrary coplanar direction to use for winding the face. Only valid when the face has at least two vertices.","wind()","Prepares the face for OpenGL triangle winding order. Sorts the vertex array in-place by increasing clockwise angle from the face's centroid.","Void","index_vertices()","Repopulates the vertex indices array to create a triangle fan. The face must be properly wound for the resulting indices to be valid."]},{"l":"Properties","p":["Description","Index array for the given face. Used in ArrayMesh creation.","Indices","Local path to the texture without the extension, relative to the FuncGodotMap node's settings' base texture directory.","Normals","PackedFloat32Array","PackedInt32Array","PackedVector3Array","Plane","Property","Raw vector data provided by the Valve 220 format during parsing. It is used to calculate rotations. The presence of this data determines how face UVs and tangents are calculated.","String","Tangent data for the given face.","Tangents","Texture","The face's plane, defined from the map file using the id Tech coordinate system. Used to calculate intersections of faces.","Transform2D","Type","UV","UV Axes","UV transform data generated during the parsing stage. Used for both Standard and Valve 220 UV formats, though rotation is not applied to the transform when using Valve 220.","Vertex array for the given face. Only populated in combination with other faces, as a result of planar intersections.","Vertex normal array for the given face. By default, set to the planar normal, which results in flat shading. May be modified to adjust shading.","Vertices"]},{"l":"FuncGodotBrushData","p":["Data struct representing a single map format brush. It is largely meant as a container for face data."]},{"i":"properties-1","l":"Properties","p":["Property","Type","Description","Planes","Array[Plane]","Raw plane data parsed from the map file using the id Tech coordinate system.","Faces","Array[FuncGodotFaceData]","Origin","Bool","True if this brush is completely covered in the Origin texture defined in the FuncGodotMap node's settings. Determined during the parsing stage and utilized during the geometry generation stage."]},{"l":"FuncGodotPatchData","p":["Data struct representing a patch mesh entity."]},{"i":"properties-2","l":"Properties","p":["Property","Type","Description","Texture","String","Local path to the texture without the extension, relative to the FuncGodotMap node's settings' base texture directory.","Size","PackedInt32Array","Defines the width M and height N dimensions of the control point grid used to sample a quadratic Bezier surface.","Points","PackedVector3Array","Flat array of size M x N containing the control points defining quadratic Bezier curves.","UVs","PackedVector2Array","Flat array of size M x N containing the UV coordinates for each control point."]},{"l":"FuncGodotGroupData","p":["Data struct representing a TrenchBroom Group, TrenchBroom Layer, or Valve VisGroup. Generated during the parsing stage and utilized during both parsing and entity assembly stages."]},{"i":"properties-3","l":"Properties"},{"l":"FuncGodotEntityData","p":["Data struct representing a map format entity."]},{"i":"properties-4","l":"Properties","p":["A collection of CollisionShape3D nodes generated during the entity assembly stage. Each node corresponds to a shape in the shapes array.","All of the entity's key value pairs from the map file, retrieved during parsing. The func_godot_properties dictionary generated at the end of entity assembly is derived from this.","Array[CollisionShape3D]","Array[FuncGodotBrushData]","Array[FuncGodotPatchData]","Array[Shape3D]","ArrayMesh","Brushes","Collision Shapes","Definition","Description","Dictionary","FuncGodotFGDEntityClass","FuncGodotGroupData","Group","Mesh","Mesh Instance","Mesh Metadata","Mesh resource generated during the geometry generation stage.","MeshInstance3D","MeshInstance3D node generated during the entity assembly stage.","Occluder Instance","OccluderInstance3D","OccluderInstance3D node generated during the entity assembly stage using the mesh resource.","Optional mesh metadata compiled during the geometry generation stage, used to determine face information from collision.","Origin","Patches","Pointer to the group data this entity belongs to.","Property","Shapes","The entity's brush data collected during the parsing stage. If the entity's FGD resource cannot be found, the presence of a single brush determines this entity to be a Solid Entity.","The entity's FGD resource, determined by matching the classname properties of each. This can only be a FuncGodotFGDSolidClass, FuncGodotFGDPointClass, or FuncGodotFGDModelPointClass.","The entity's patch def data collected during the parsing stage. If the entity's FGD resource cannot be found, the presence of a single patch def determines this entity to be a Solid Entity.","True global position of the entity's generated node that the mesh's vertices are offset by during the geometry generation stage.","Type","Vector3"]},{"i":"methods-1","l":"Methods","p":["Method","Description","Return type","is_visual()","Checks the entity's FGD resource definition, returning whether the Solid Class has a MeshInstance3D built for it.","Bool","is_collision_convex()","Checks the entity's FGD resource definition, returning whether the Solid Class CollisionShapeType is set to Convex.","is_collision_concave()","Checks the entity's FGD resource definition, returning whether the Solid Class CollisionShapeType is set to Concave.","is_smooth_shaded(smoothing_property: String = \"_phong\")","Determines if the entity's mesh should be processed for face smoothing. The smoothing property can be retrieved from the map node's settings.","get_smoothing_angle(smoothing_angle_property: String = \"_phong_angle\")","Retrieves the entity's smoothing angle to determine if the face should be smoothed. The smoothing angle property can be retrieved from the map node's settings.","Float"]}],[{"l":"FuncGodotEntityAssembler","p":["Entity assembly class that is instantiated by a FuncGodotMap node."]},{"l":"Signals","p":["Signal","Description","declare_step","Emitted when a step in the entity assembly process is completed. It is connected to FuncGodotUtil's print_profile_info() method if the FuncGodotMap's Show Profiling Info build flag is set."]},{"l":"Methods","p":["apply_entity_properties(node: Node, data: EntityData)","Attempts to retrieve a script via class name, to allow for GDScript class instantiation.","build(map_node: FuncGodotMap, entities: Array[EntityData], groups: Array[GroupData])","Converts the String values of the entity data's properties Dictionary to various Variant formats based upon the entity definition's class properties, then attempts to send those properties to a func_godot_properties Dictionary and an apply_func_godot_properties() method on the node. A deferred call to build_complete() is also made.","Description","Error","Generate a node from entity data. The returned node value can be null, in the case of Solid Class entities with no brush data.","generate_entity_node(entity_data: EntityData, entity_index: int)","generate_group_node(group_data: GroupData)","generate_point_entity_node(node: Node, node_name: String, properties: Dictionary, definition: FuncGodotFGDPointClass)","generate_solid_entity_node(node: Node, node_name: String, data: EntityData, definition: FuncGodotFGDSolidClass)","Generates a Node3D for a group's SceneTree representation and links the new Node3D to that group.","Generates and assembles a new Node based upon processed entity data. Depending upon provided data, additional MeshInstance3D, CollisionShape3D, and OccluderInstance3D nodes may also be generated.","Generates and assembles a new Node or PackedScene based upon processed entity data.","get_script_by_class_name(name_of_class: String)","Main entity assembly process called by the map node. Generates and sorts group nodes in the SceneTree first. Then generates and assembles nodes based upon the provided entity data and adds them to the SceneTree.","Method","Node","Node3D","Return type","Script","Void"]}],[{"l":"FuncGodotMap","p":["A scene generator node that parses a Quake MAP or Hammer VMF file using a FuncGodotFGDFile. Uses a FuncGodotMapSettings resource to define map build settings."]},{"l":"Signals","p":["Signal","Description","build_failed","Emitted when the build process fails.","build_complete","Emitted when the build process succesfully completes."]},{"l":"Methods","p":["Method","Description","Return type","fail_build(reason: String, notify: bool = false)","Map build failure handler. Displays error message and emits build_failed signal.","Void","clear_children()","Frees all children of the map node. WARNING! Does not distinguish between generated and placed nodes!","verify()","Validates the map file for the build process.","Bool","build()","Cleans the map node of any children, then initiates and oversees the build process."]},{"l":"Properties"},{"l":"FuncGodotMapSettings","p":["Albedo Map Pattern","Ao Map Pattern","Array","Array[Resource]","Array[String]","Automatic PBR material generation albedo map pattern.","Automatic PBR material generation ambient occlusion map pattern.","Automatic PBR material generation emission map pattern.","Automatic PBR material generation height map pattern.","Automatic PBR material generation metallic map pattern.","Automatic PBR material generation normal map pattern.","Automatic PBR material generation ORM map pattern.","Automatic PBR material generation roughness map pattern.","Automatic ShaderMaterial generation mapping patterns. Only used when default_material is a ShaderMaterial. Keys should be the names of the shader uniforms while the values should be the suffixes for the texture maps. Patterns only use one replacement String: the texture name, ex: \"%s_normal\".","Base directory for loading and saving materials. When building materials, FuncGodot will search this directory for material resources with matching names to the textures assigned to map brush faces. If not found, will fall back to Base Texture Dir.","Base directory for textures. When building materials, FuncGodot will search this directory for texture files with matching names to the textures assigned to map brush faces.","Base Material Dir","Base Texture Dir","Bool","Build Settings","Class property that contains the angular threshold that determines when a Solid Entity's mesh vertices are smoothed.","Class property that contains the snapping epsilon for generated vertices of FuncGodotFGDSolidClass entities. Utilizing this property can help reduce instances of seams between polygons.","Class property that determines whether the Solid Entity performs mesh smoothing operations.","Clip Texture","Default class property to use in naming generated nodes. This setting is overridden by name_property in FuncGodotFGDEntityClass. Naming occurs before adding to the SceneTree and applying properties. Nodes will be named entity_ + name_property. NOTE: Node names should be unique, otherwise you may run into unexpected behavior!","Default Material","Default Material Albedo Uniform","Description","Dictionary[String, String]","Emission Map Pattern","Entity Fgd","Entity Name Property","Entity Node Groups","Entity Settings","Entity Smoothing Angle Property","Entity Smoothing Property","File extension to search for Material definitions.","File extensions to search for texture data.","Float","FuncGodotFGDFile","Height Map Pattern","If true, will organize Scene Tree using TrenchBroom Layers and Groups or Hammer Visgroups. Groups will be generated as Node3D nodes. All non-entity structural brushes will be moved out of their groups and merged into the Worldspawn entity. Any Layers toggled to be omitted from export in TrenchBroom and their child entities and groups will not be built.","Inverse Scale Factor","Material","Material File Extension","Material used as a template when generating missing materials.","Materials","Metallic Map Pattern","Normal Map Pattern","Optional array of node groups to add all generated nodes to.","Optional path for the clip texture, relative to Base Texture Dir. Brush faces textured with the clip texture will have those faces removed from the generated Mesh but not the generated Shape3D.","Optional path for the origin texture, relative to Base Texture Dir. Brush faces textured with the origin texture will have those faces removed from the generated Mesh and Shape3D. The bounds of these faces will be used to calculate the origin point of the entity.","Optional path for the skip texture, relative to Base Texture Dir. Brush faces textured with the skip texture will have those faces removed from the generated Mesh. If the FuncGodotFGDSolidClass collision_shape_type is set to concave then it will also remove collision from those faces in the generated Shape3D.","Optional QuakeWADFile resources to apply textures from. See the Quake Wiki for more information on Quake Texture WADs. Supports both Quake WAD2 and Half-Life WAD3 formats.","Origin Texture","Orm Map Pattern","Property","Ratio between map editor units and Godot units. FuncGodot will divide brush coordinates by this number when building. This does not affect entity properties unless scripted to do so. See Inverse Scale Factor for more information.","Resource file that translates map file classnames into Godot nodes and packed scenes.","Reusable map settings configuration for FuncGodotMap nodes.","Roughness Map Pattern","Sampler2D uniform that supplies the Albedo in a custom shader when Default Material is a ShaderMaterial.","Save automatically generated materials to disk, allowing reuse across FuncGodotMap nodes. NOTE: Materials do not use the Default Material settings after saving.","Save Generated Materials","Shader Material Uniform Map Patterns","Skip Texture","String","Texel size for UV2 unwrapping. Actual texel size is uv_unwrap_texel_size / inverse_scale_factor. A ratio of 1/16 is usually a good place to start with (if inverse_scale_factor is 32, start with a uv_unwrap_texel_size of 2). Larger values will produce less detailed lightmaps. To conserve memory and filesize, use the largest value that still looks good.","Texture File Extensions","Texture Wads","Textures","Type","Use Groups Hierarchy","Uv Unwrap Texel Size","Vertex Merge Distance Property"]}],[{"l":"FuncGodotParser","p":["MAP and VMF parser class that is instantiated by a FuncGodotMap node."]},{"l":"Signals","p":["Signal","Description","declare_step","Emitted when a step in the parsing process is completed. It is connected to FuncGodotUtil's print_profile_info() method if the FuncGodotMap's Show Profiling Info build flag is set."]},{"l":"Methods","p":["Method","Description","Return type","parse_map_data(map_file: String, map_settings: FuncGodotMapSettings)","Parses the map file, generating entity and group data and sub-data, then returns the generated data as an array of arrays. The first array is Array[FuncGodotEntityData], while the second array is Array[FuncGodotGroupData].","Array[Array]","_parse_quake_map(map_data: PackedStringArray, map_settings: FuncGodotMapSettings)","Parser subroutine called by parse_map_data(), specializing in the Quake MAP format.","_parse_vmf(map_data: PackedStringArray, map_settings: FuncGodotMapSettings)","Parser subroutine called by parse_map_data(), specializing in the VMF format used by Hammer based editors."]}],[{"l":"FuncGodotUtil","p":["Static class with a number of reuseable utility methods that can be called at Editor or Run Time."]},{"l":"Methods","p":["Adds PBR textures to an existing BaseMaterial3D.","Array[Dictionary]","Array[Vector3]","Bool","build_base_material(map_settings: FuncGodotMapSettings, material: BaseMaterial3D, texture: String)","build_texture_map(entity_data: Array[EntityData], map_settings: FuncGodotMapSettings)","Builds both materials and sizes dictionaries for use in the geometry generation step of the build process. Both dictionaries use texture names as keys. The materials dictionary uses [Material] as values, while the sizes dictionary saves the albedo texture sizes to aid in UV mapping.","Check if a point is inside a convex hull defined by a series of planes by an epsilon constant.","Connected by the FuncGodot Map node to the build process' sub components if the Show Profiling Info build flag is set. Also called by the Map node.","Conversion from id tech coordinate system to Godot, from a top-down perspective.","Create a Curve3D and bake points.","create_curve(start: Vector3, control: Vector3, end: Vector3, bake_interval: float = 0.05)","Curve3D","Description","Determines which UV format is being used and returns the tangent.","Determines which UV format is being used and returns the UV coordinate.","earches for a Texture2D within the base texture directory or the WAD files added to map settings. If not found, a default texture is returned.","elevate_quadratic(p0: Vector3, p1: Vector3, p2: Vector3)","filter_face(texture: String, map_settings: FuncGodotMapSettings)","Filters faces textured with any of the tool textures during the geometry generation step of the build process.","Filters faces textured with Clip during the geometry generation step of the build process.","Filters faces textured with Origin during the parsing and geometry generation steps of the build process.","Filters faces textured with Skip during the geometry generation step of the build process.","get_face_tangent(face: FaceData)","get_face_vertex_uv(vertex: Vector3, face: FaceData, texture_size: Vector2)","get_quake_tangent(normal: Vector3, uv_y_scale: float, uv_rotation: float)","get_quake_uv(vertex: Vector3, normal: Vector3, uv_basis := Transform2D.IDENTITY, texture_size := Vector2.ONE)","get_valve_tangent(u: Vector3, v: Vector3, normal: Vector3)","get_valve_uv(vertex: Vector3, u_axis: Vector3, v_axis: Vector3, uv_basis := Transform2D.IDENTITY, texture_size := Vector2.ONE)","id_to_opengl(vec: Vector3)","is_clip(texture: String, map_settings: FuncGodotMapSettings)","is_origin(texture: String, map_settings: FuncGodotMapSettings)","is_point_in_convex_hull(planes: Array[Plane], vertex: Vector3)","is_skip(texture: String, map_settings: FuncGodotMapSettings)","load_texture(texture_name: String, wad_resources: Array[QuakeWadFile], map_settings: FuncGodotMapSettings)","Math","Method","newline()","op_swizzle_vec3_w(xyz: Vector3, w: float)","op_vec3_avg(array: Array[Vector3])","op_vec3_sum(lhs: Vector3, rhs: Vector3)","PackedFloat32Array","Patch Def","print_profile_info(message: String, signature: String)","Return a string that corresponds to the current OS's newline control characters.","Return type","Returns the average vector of an array of vectors.","Returns the control points that defines a cubic curve for a equivalent input quadratic curve.","Returns the sum of the two input vectors. Useful for lambda operations.","Returns the tangent calculated from the original id Standard UV format.","Returns the tangent calculated from the Valve 220 UV format.","Returns UV coordinate calculated from the original id Standard UV format.","Returns UV coordinate calculated from the Valve 220 UV format.","String","Texture2D","Textures","Update a Curve3D given quadratic inputs.","update_ref_curve(curve: Curve3D, p0: Vector3, p1: Vector3, p2: Vector3, bake_interval: float = 0.05)","UV Mapping","Vector2","Vector3","Void"]}],[{"l":"Helpful Links"},{"l":"Godot and FuncGodot","p":["Official FuncGodot Discord If you've got questions on FuncGodot or Godot, we've got some extremely helpful community members who are generally happy to answer them. Be respectul and patient: we're all volunteers, doing this on our free time and out of a love for the community.","FuncGodot Repositories The official repositories contain helpful example projects that can show you how you might design your own games to take advantage of FuncGodot.","Godot 4 Latest Stable Documentation This may seem obvious or sarcastic, but this is probably the best source for almost all of the answers to almost all of your questions. This is your best friend. Most FuncGodot questions people have are really just Godot questions that don't involve FuncGodot at all. If you need to know how to do something in Godot, it's in this manual (literally).","RhapsodyInGeek's GitHub Repositories Tim often shares a lot of his work on GitHub, most of it licensed under Creative Commons Zero and MIT. Not all of it can be dragged and dropped into your own projects, but hopefully you'll come away from them learning something new.","Valve Developer Community Wiki's FGD Page This is an extremely helpful resource in learning how FGD files work, and not just for Valve games or Hammer: it covers how FGD files are used by other editors too. If you want to take advantage of some more advanced features of FuncGodot's entity and configuration systems, it's helpful to study up on the FGD language that powers it."]},{"l":"TrenchBroom and Quake","p":["Dumptruck_ds's TrenchBroom Tutorials Some of these tutorials are a little bit dated as some features have changed a little, but overall these will teach you not only the fundamentals but get you acquainted with some of the more advanced techniques and improve your TrenchBroom workflow. You can also learn more about Quake map scripting, which might inspire some design patterns for your own game.","Slipseer's TrenchBroom Tutorials YouTube channel with some great tutorials. Not a lot on here, but what's here can definitely level up a novice mapper's skill set.","Slipgate Sightseer A very active and well done Quake modding and mapping site. Easy to navigate layout. Run by the best in the business. Check it out, even if just to get inspired by all the possibilities with TrenchBroom mapping. It's not just a lot of brown blocks (though those are cool, too).","id Software GitHub Repository An incredible source for study. John Carmack began a trend a long while back of releasing the source code for id Software games, and this repository stretches as far back as Wolfenstein 3D. The most relevant repositories for you might be the Quake 1, 2, and 3 sources. Also provided are the Quake 1 QC files, the code for almost the entirety of the gameplay.","Quake Mapping Discord Discord server where the best of the best hang out. If you have questions on Quake or TrenchBroom, mapping or modding, the people here can teach you everything you want to know about it.","Map-Center Discord Discord server for Quake series mapping, including Quake II and Quake III Arena. A good resource for various map editors, including NetRadian-Custom."]},{"l":"J.A.C.K. and Half-Life","p":["Lymphoid's Half-Life Mapping Tutorials Not as hilarious as Dimbeak's tutorials but Lymphoid's videos are a few years more relevant and have a fairly slower pace. Not everything is applicable to the J.A.C.K. > FuncGodot > Godot pipeline, but what can't be used directly could still be useful in knowing for your own implementations.","Vhetutor's Tutorials Many of these tutorials are for Hammer, but they give pretty great overviews of how scripted sequences are designed in a Half-Life map. Once again, not directly applicable but these tutorials could be very informative in trying to design your own scripted sequences, no matter your map editor.","The Whole Half-Life A site dedicated to Half-Life level design and modding. Deep dive into the knowledge base of Half-Life modding, raid its vaults, and escape with new design patterns that you can use for your FuncGodot workflow.","Half-Life Source Code Another incredible source for study. Half-Life does a lot of really interesting things with its design. Definitely take a peek through and see what you can learn."]},{"l":"Useful Tools","p":["Aseprite The most important game dev tool you will ever purchase. It's a wonderful pixel paint program that trivializes sprite work and animation.","Krita Free and open source paint application that serves really well as an Adobe Photoshop alternative. I use this for my higher res image assets and concept art.","Material Maker Really incredible open source procedural materials authoring tool made with Godot, available at the variable cost of name-your-own-price. Highly recommended by the community."]}],[{"l":"Installing FuncGodot"},{"l":"Preliminary Requirements","p":["FuncGodot's official requirement is always the latest Godot 4.x release. If you manage to make it work on an older release of Godot 4, awesome! But you're on your own if you run into issues.","FuncGodot is written in pure GDScript and as such has no other dependencies.","This manual assumes you have an intermediate level of knowledge with Godot and your chosen map editor."]},{"l":"Map Editor Compatibility","p":["FuncGodot directly supports the following editors with configuration resources:","TrenchBroom 2025","NetRadiant Custom 1.6","FGD outputs have also been tested with these editors:","J.A.C.K.","FuncGodot is designed to be as map editor agnostic as possible. If you use an editor that can output Quake or Half-Life format map files, please let us know on GitHub or Discord so we can try our best to either support it directly or document the configuration process!"]},{"l":"Downloading the Plugin","p":["There are 3 places to download FuncGodot. The first two places are both found on the FuncGodot GitHub Repository. The first location is the Code Download, and it is always the most up to date version of the plugin. It includes all merges, including both feature updates and bug fixes. Sometimes this version can be significantly up to date, but may also contain less refined features than the other options below.","An image displaying where to find the GitHub Code Download. It shows a green button that says 'Code' with an open menu. At the bottom of the menu is a button that says 'Download Zip'.","The second location is the GitHub repository's Releases. This is the second most up to date download and is considered the official \"Stable Release\" of the plugin.","An image displaying where to find the GitHub Stable Release. It shows a circled location on the right side of the GitHub repository page that says 'Releases'.","The final location is the Godot Asset Library. While the intent is to keep the Asset Library release in line with the GitHub Stable Release, sometimes these releases can be \"desynced\" for one reason or another. We're a small team of volunteers here, so please be patient with us! If you're finding some bugs or issues with the Asset Library release, try downloading the plugin from one of the other two locations.","Our intent is to keep the Stable Releases as reliable as possible, so typically only critical fixes will be pushed with some urgency while new features or quality of life improvements tend to simmer a bit more in the code base.","In any case, pick the download option that suits you best. If you downloaded the plugin from GitHub, extract the func_godot folder to your Godot project's addons folder. If you downloaded from the Asset Library, it should do this for you automatically. Once the plugin is copied to your project, remember to enable the plugin in your Project Settings.","Godot Project Settings window, Plugins tab. FuncGodot is listed and enabled."]}],[{"l":"Map Editor Configuration","p":["In order to map for Godot in your chosen map editor, you'll need to tell your map editor about your game. Each map editor has its own method of doing this. While FuncGodot can import any map file using the Quake Map format, official support is currently limited to only those that support the FGD format."]},{"l":"TrenchBroom","p":["TrenchBroom logo","TrenchBroom is the most commonly recommended editor for FuncGodot, with multiple resources dedicated to configuring it. The primary configuration resource is the TrenchBroomGameConfig, with the TrenchBroomTag providing additional quality of life options in the editor.","You'll need a TrenchBroom Game Config resource in order to build and export a game configuration file for TrenchBroom. Let's take a look at the resource properties:","TrenchBroomGameConfig properties","Most of these properties should be fairly obvious in their purpose. The FGD File should be your master FGD that contains all of your other base FGDs and entities. Entity Scale only scales the display models.","Brush Tags and Brushface Tags are strictly for TrenchBroom and have no effect in Godot. They can affect shortcut keys and have transparency effects applied to them, along with a few other features. FuncGodot comes with a few pre-made common tags. Feel free to use them in your own GameConfig resources.","Exporting the Game Config will use the directory set in your Local Configuration's Trenchbroom Game Config Folder. Consult the TrenchBroom Manual's Game Configuration documentation for more information. Once you've exported your Game Config, open up TrenchBroom and click New Map. You should now see your project in the games list.","TrenchBroom Config 2","You'll need to set the game path so that TrenchBroom can find your game's textures and any models if you created some for it. Open TrenchBroom's preferences and set your game's path to the one you set to Map Editor Game Path with the Local Configuration.","TrenchBroom Config 3","Now you should be ready to start mapping for Godot with TrenchBroom!"]},{"l":"J.A.C.K.","p":["J.A.C.K. logo","Due to how games are configured in J.A.C.K., FuncGodot does not have any dedicated resources for it but the process is still fairly simple.","Make sure your Local Configuration's FGD Output Folder is pointing to your game's folder in J.A.C.K.'s game configuration folder. When you export an FGD file, FuncGodot will print in the Godot Output where it was saved to.","J.A.C.K. Config 1","Once exported, you'll need to add your game to the Game Configurations list. Be sure to add your newly exported FGD as well.","J.A.C.K. Config 2 J.A.C.K. Config 3","Lastly you'll want to set your Base Game and Source Maps directories.","J.A.C.K. Config 4","When it comes to textures, something to keep in mind is that you do not have to use the same exact texture files from your project. You can set up a WAD file for use with J.A.C.K. but then in your Godot project have loose texture files and premade materials. As long as the relative texture paths match without the file extensions, FuncGodot will be able to select the correct textures. That said, FuncGodot does support using WAD files with your maps. Use whichever method is right for your project.","And with that, you should be all set to start mapping in J.A.C.K.!","J.A.C.K. Config 5"]},{"l":"NetRadiant Custom","p":["Exporting the Gamepack Config will use the directory set in your Local Configuration's NetRadiant Custom Gamepacks Folder. After you've built the gamepack, open up NetRadiant Custom.","Lastly, you'll want to go to Edit > Preferences > Settings > Brush, then change New map Brush Type to Valve 220.","NetRadiant Custom logo","NetRadiant Custom receives FuncGodot support through both local configuration and dedicated resources. The primary configuration resource is the NetRadiantCustomGamepackConfig. The NetRadiantCustomShader resource offers additional options for texture display in the editor. It is highly recommended that you familiarize yourself with NetRadiant Custom before attempting to use it with FuncGodot.","NetRadiant Custom setup 1","NetRadiant Custom setup 2","NetRadiant Custom setup 3","NetRadiantCustomGamepackConfig properties","Now you should be ready to start mapping for Godot with NetRadiant Custom!","Once open, you'll want to go to Edit > Preferences > Global > Game. If you did everything correctly so far you should find your game in the list. Select it and then select Okay. NetRadiant Custom will need to restart.","The Base Game Path is the folder containing your maps and textures, relative to your project directory without res://. Leave this blank to use your project's root directory. If you do use a separate mapping folder within your project make sure that you follow the same formatting as the Gamepack Name: all lower case and no special characters.","The Default Scale sets the default texture scale.","The Game Name and Fgd File properties should be fairly obvious. Make sure that the FGD file you choose is the master FGD that contains all of your other base FGDs and entities.","The Gamepack Name is the most important one to get right. This will be the name of your gamepack folder, your base game folder, and your gamepack file. The Gamepack Name MUST be all lower case with NO special characters. Bad things can happen otherwise!","The Netradiant Custom Shaders array is a resource array for... NetRadiantCustomShader resources! These will be compiled into a .shader file included with the rest of your gamepack configuration. Simply empty the array if you don't wish to use any special shaders. This only affects NetRadiant Custom and has no effect on your Godot shaders and materials.","The Skip and Clip Texture properties set the texture paths for a number of different shader settings in the gamepack, including caulk> and nodraw.","The Texture Types, Model Types, and Sound Types arrays are the lists of compatible file types that NetRadiant Custom will attempt to look for. It's generally fine to leave this as is and is offered for the sake of more advanced users.","You'll be prompted to find your game's engine path. Use your Godot project's root folder.","You'll need a NetRadiant Custom Gamepack Config resource in order to build and export a gamepack configuration for NetRadiant Custom. Let's take a look at the resource properties:"]}],[{"l":"Naming Patterns","p":["Recall that every entity has a classname that we define in our Entity Definition resource. One important consideration to make is that naming conventions matter. The first word of an entity's name up until the first underscore will be provided its own group in the map editor. Taking advantage of this can help keep your entities organized in a few spots and in some editors provide convenient filtering options.","When combined with brush tags in TrenchBroom configurations, this feature gains additional powers like in-editor transparency and keyboard shortcuts.","FuncGodot has a pair of prebuilt TrenchBroomTag resources for func* and trigger* brush classes. Feel free to use these either directly or as a base for your own brush tags.","Additionally, your map editor will also handle Point Class orientation through the key value pairs angle and mangle differently depending upon the classname. Setting the mangle for an entity type in the \"light_*\" group or with the \"info_intermission\" classname will have altered orientation behavior. To see the differences, try to parse the code block in FuncGodotMap that handles translating Quake angles into Godot rotations:","Image showing how node rotation is calculated by the FuncGodotMap.","Anyway, just make sure to give a little bit more thought to your naming conventions."]}],[{"l":"NetRadiant Custom Resources","p":["FuncGodot has limited support for NetRadiant Custom. All standard entity types and shaders are supported. Patches are unsupported at this time, and bit flag key values are restricted to a single spawnflags key. FuncGodot offers two resources to help configure NetRadiant Custom gamepacks."]},{"l":"NetRadiantCustomGamepackConfig","p":["Array[Resource]","Base Game Path","Bool","Builds a gamepack for NetRadiant Custom.","Button to export / update this gamepack's configuration in the NetRadiant Custom Gamepacks Folder.","Clip Texture","Clip texture path that gets applied to weapclip and nodraw shaders.","Commands to include in the exported gamepack's default_build_menu.xml. Keys, specified as a String, define the build option name as you want it to appear in Radiant. Values represent commands taken within each option. They may be either a String or an Array of String elements that will be used as the full command-line text issued by each command within its associated build option key. They may reference entries in default_build_menu_variables by using brackets, eg: [variable_key_name].","Default Build Menu Commands","Default Build Menu Variables","Default Scale","Default scale of textures in NetRadiant Custom.","Description","Dictionary","Directory path containing your maps, textures, shaders, etc... relative to your project directory.","Export File","Fgd File","FGD resource to include with this gamepack. If using multiple FGD resources, this should be the master FGD that contains them in the base_fgd_files resource array.","FuncGodotFGDFile","Game Name","Gamepack folder and file name. Must be lower case and must not contain special characters.","Gamepack Name","Model Types","Name of the game in NetRadiant Custom's gamepack list.","Netradiant Custom Shaders","NetRadiantCustomShader resources for shader file generation.","PackedStringArray","Property","Skip Texture","Skip texture path that gets applied to caulk and nodrawnonsolid shaders.","Sound Types","String","Supported audio file types.","Supported model file types.","Supported texture file types.","Texture Types","Type","Variables to include in the exported gamepack's default_build_menu.xml. Each String key defines a variable name, and its corresponding String value as the literal command-line string to execute in place of this variable identifier. Entries may be referred to by key in default_build_menu_commands values."]},{"l":"NetRadiantCustomShader","p":["Resource that gets built into a shader file that applies a special effect to a specified texture in NetRadiant Custom.","Property","Type","Description","Texture Path","String","Path to texture without extension, eg: `textures/special/clip`.","Shader Attributes","Array[String]","Array of shader properties to apply to faces using Texture Path."]}],[{"l":"Project Configuration"},{"l":"Directory Structure","p":["Designing a directory structure for your game is its own art, and the layout of your project files can depend greatly on the kind of game you're making. That said, it is generally recommended you create an organization that splits off your TrenchBroom resources from the rest of your Godot assets.","If you're using TrenchBroom, you may already be aware it has a handy backup feature where it creates an autosave folder to periodically save backups of your map file. Less useful is the tendency for Godot to import these backups as well.","However, Godot has its own handy feature to combat this. Any directory with a .gdignore file will not be scanned and imported by Godot. To save yourself some headache later, open the autosave sub-directory in your operating system's file explorer. If using Windows, make sure you have File Name Extensions enabled under the View tab. Create a new text document in the sub-directory and rename it .gdignore, exactly like that with the .txt extension removed.","And just like that, we won't have to deal with Godot constantly importing hundreds of backup map files from our project! You can do this for any directory that you don't want Godot to import files from, such as the folder that contains all of your display models intended to be used only with your map editor."]},{"l":"FuncGodot Local Config","p":["FuncGodot has the option of using a FuncGodotLocalConfig resource to create local project wide settings for your other FuncGodot resources. These settings are applied only to your machine, in order to better facilitate working with a team that may not have the same drive or directory setup or even the same map editor as you yourself use.","You won't create the FuncGodotLocalConfig resource for your project, as this resource doesn't actually save anything to itself directly. Instead you will use the pre-made func_godot_local_config.tres resource found in the addons/func_godot/ folder.","Location of func_godot_local_config.tres in the Godot project File System."]},{"l":"Local Config Properties","p":["Viewing this resource's properties in the inspector, you'll be greeted with some options. We'll ignore the Export Func Godot Settings and Reload Func Godot Settings property for now.","FuncGodotLocalConfig resource inspector.","For the FGD Output Folder, you'll want to locate your map editor's game configuration folder or installation folder. Create a sub folder for your game's configuration and set the FGD Output Folder to that sub-folder. This might look something like C:/GameDev/TrenchBroom/Games/MyGame/ or C:/GameDev/J.A.C.K/MyGame/. This tells FuncGodot where to save generated configuration and FGD files when you click on their export button.","The Trenchbroom Game Config Folder is the location of your game's TrenchBroom Game Config folder. This might (but doesn't have to be) the same as your FGD Output Folder. When you export your TrenchBroomGameConfig resource, it will automatically export the FGD file to this folder as well, overriding the FGD Output Folder property.","The Netradiant Custom Gamepack Folder is a little different, in that it should point to your NetRadiant Custom's gamepacks folder (eg: C:/GameDev/NetRadiant Custom/gamepacks/). This will also override the FGD Output Folder when you export your NetRadiantCustomGamepackConfig resource, as NetRadiant Custom splits up gamepack configurations across several folders and files.","The Map Editor Game Path refers to what your Map Editor considers the location of your project. This might look something like C:/GameDev/MyGodotProject/ or C:/GameDev/MyGodotProject/trenchbroom/. The intended use for this is to streamline certain FGD resource paths, like the FuncGodotFGDModelPointClass's model export location.","The Game Path Models Folder is the default folder path relative to your Map Editor Game Path that tells FuncGodot where to save generated model files to. For example, with a Map Editor Game Path value of C:/GameDev/MyGodotProject/trenchbroom/ and a Game Path Models Folder value of models, the generated model file will be saved to C:/GameDev/MyGodotProject/trenchbroom/models/. Currently only used by FuncGodotFGDModelPointClass.","The Default Inverse Scale Factor setting doesn't affect FuncGodotMapSettings resources or how the map builds. It currently only affects scaling display models for FuncGodotFGDModelPointClass definitions in map editors other than TrenchBroom."]},{"l":"Exporting the Local Config","p":["Remember that Export Func Godot Settings property I told you to ignore earlier? Once you have your settings in place, go ahead and click it. It will automatically generate a MyGameFuncGodotConfig.json file in your Godot project's user data folder.","NOTE: You need to run your project at least once before attempting to export settings, so that the user:// folder can be created by Godot! Otherwise you will run into an error and the config file will not export!","This is how we keep local settings local. Upon opening your project, FuncGodot will automatically update func_godot_local_config.tres to load the data from the generated JSON file found in your user data folder, and setting the resource's Export property to true will overwrite that file with the new settings. These settings are not saved to source control, allowing teams to work together more easily and more flexibly.","If you make a change you didn't mean to commit and you haven't yet exported, you can use the Reload option to revert your unwanted changes."]}],[{"l":"Project Settings","p":["FuncGodot adds a few helpful Project Settings to Godot.","Property","Type","Description","Default Map Settings","FuncGodotMapSettings","Map settings resource a new FuncGodotMap will attempt to use by default when added to the SceneTree.","Model Point Class Save Path","String","Relative directory path from your Map Editor Game Path to a subfolder where GLB files generated by FuncGodotFGDModelPointClass will be saved.","Default Inverse Scale Factor","Float","Scale factor that affects how FuncGodot FGD Model Point Class entities scale their map editor display models. Not used with TrenchBroom, use TrenchBroom Game Config's Entity Scale expression instead."]},{"l":"FuncGodotLocalConfig","p":["Local machine project wide settings. Can define global defaults for some FuncGodot properties."]},{"l":"DO NOT CREATE A NEW RESOURCE!","p":["Bool","Button to reload the local machine project configuration settings in your game's user:// folder. This can be used in case you need to revert changes to the Local Config resource, so long as you have not export your changes already.","Button to save the local machine project configuration settings in your game's user:// folder.","Description","Export Func Godot Settings","Fgd Output Folder","Global directory path that FGD files save to when exported from their properties. Overridden when exported from a game configuration resource like TrenchBroomGameConfig.","Global directory path to your mapping folder where all of your mapping assets exist. This is usually either your project folder or a subfolder within it.","Global directory path where your NetRadiant Custom gamepacks are saved. On Windows this is the gamepacks folder in your NetRadiant Custom installation.","Global directory path where your TrenchBroom game configuration should be saved to. Consult the TrenchBroom Manual's Game Configuration documentation for more information.","Handling local project configuration settings in this way means they need to be set individually on every machine you load your project onto. These settings are not saved to source control. The benefit is that this allows teams to more easily work together even with drastically different tool installation paths.","Map Editor Game Path","Netradiant Custom Gamepacks Folder","NOTE: You need to run your project at least once before attempting to export settings, so that the user:// folder can be created by Godot! Otherwise you will run into an error and the config file will not export!","Property","Reload Func Godot Settings","String, Global Directory","This resource works by saving a MyGameFuncGodotConfig.json configuration file to your game's user:// folder and pulling the properties from that config file rather than this resource. Use the premade addons/func_godot/func_godot_local_config.tres instead.","Trenchbroom Game Config Folder","Type"]}],[{"l":"Runtime Map Building","p":["There are times where you may want to build maps while in the middle of running your game, whether it's for loading levels from map files instead of scenes, procedural generation, or as a way to support user-made maps. Runtime map building can also be combined with map editor launch configurations to provide a largely seamless experience between making a map and seeing it in-game."]},{"l":"Setting up Runtime Map Building","p":["To build a map at Runtime, start by either using a templated scene with an empty FuncGodotMap or instantiating one. Next you'll need to make sure to set either the local_map_file or global_map_file to your map's file path. Don't use load() here! That will be taken care of in the next step.","Once your map file path has been set, you can run the build() method from the FuncGodotMap node. When this is done, your map will be built just as it would have been by pressing the Build button in the Editor, along with all of the entity callbacks. Be aware that the Engine.is_editor_hint() conditional will return as false, in case you use it to control properties handling through the FuncGodot entity callbacks.","When the map builds, it will emit the signals build_complete or build_failed. You can use these signals to handle errors gracefully and to run any post-build code you need to run.","An example of runtime map building is as follows:","This example can be found in the func_godot_runtime_building repository."]},{"l":"Building from Map Editors","p":["Much like id Tech engine games, it's possible to build and launch directly into a map from some map editors. This can be quite a helpful tool for testing rapid iterations."]},{"l":"Godot Project Setup Example","p":["To build and launch our maps from the editor, you'll need to employ the OS class' ability to retrieve command line arguments. A basic example might look something like this:","This example can be found in the func_godot_runtime_building repository.","_ NOTE: You can extend this to have more commands like God mode or Debug mode as your game needs, and use them when launching in editor._"]},{"l":"Setting Up Your Editor","p":["In every map editor you'll need to specify both an executable and parameters in your build options. The executable can be either the exported binary of your game, or the Godot Editor binary if launching from a Godot project. To run your game from the Godot project, be sure to use the --path parameter, as defined in Godot's Command line reference."]},{"l":"TrenchBroom","p":["The TrenchBroom Reference Manual covers Compiling Maps quite thoroughly. If you chose to use the Godot Editor for your launch executable, make sure to start your parameters with the --path command. You'll then add the -- run_map:: build command we defined earlier, using the built-in TrenchBroom variables: ${MAP_BASE_NAME} to get the name of the currently opened map file, ${MAP_DIR_PATH} for the path to the currently opened map file, and ${GAME_DIR_PATH} for the path to the current game as defined in the game preferences.","An example of the parameters to launch from the Godot Editor will look something like this: --path ${GAME_DIR_PATH} -- run_map::${MAP_DIR_PATH}/${MAP_BASE_NAME}.map","To run your map from TrenchBroom, navigate to Run Compile Map.","Select the godot executable for the tool path.","For the parameters, define the path to your game and then pass in the map we want to run. Here we use the example given above.","Now when you press Compile your game should launch using the parameters you defined!","_ NOTE: ${GAME_DIR_PATH} and ${MAP_DIR_PATH} both fail if the file path has spaces. If this affects you, you can use the exact path with quotes around it._"]},{"l":"NetRadiant Custom","p":["To launch from NetRadiant Custom, you must define at least one or more build commands which are defined in your default_build_menu.xml file located in your game's gamepack folder for its build processes. These build commands may refer to build variables also defined here, or one of the default variables NetRadiant provides for you. You may either write them directly in the file yourself, or define them in the NetRadiant Custom GamePack Config resource. To preview these defaults, or any of your defined commands and their current values, select Build Customize... in the top menu bar and check the build variables option.","A build profile might look something like this:","After making any changes to this file, restart NetRadiant Custom. The build menu will now show your new options; selecting one will run the command you defined above!"]}],[{"l":"Textures"},{"l":"How Textures Work In FuncGodot","p":["// entity 1 { classname func_detail // brush 0 { ( -32 -64 -16 ) ( -32 -63 -16 ) ( -32 -64 -15 ) __TB_empty [ 0 -1 0 0 ] [ 0 0 -1 0 ] 0 1 1 ( -64 -32 -16 ) ( -64 -32 -15 ) ( -63 -32 -16 ) __TB_empty [ 1 0 0 0 ] [ 0 0 -1 0 ] 0 1 1 ( -64 -64 -32 ) ( -63 -64 -32 ) ( -64 -63 -32 ) special/clip [ -1 0 0 0 ] [ 0 -1 0 0 ] 0 1 1 ( 64 64 32 ) ( 64 65 32 ) ( 65 64 32 ) __TB_empty [ 1 0 0 0 ] [ 0 -1 0 0 ] 0 1 1 ( 64 32 16 ) ( 65 32 16 ) ( 64 32 17 ) special/clip [ -1 0 0 0 ] [ 0 0 -1 0 ] 0 1 1 ( 32 64 16 ) ( 32 64 17 ) ( 32 65 16 ) special/clip [ 0 1 0 0 ] [ 0 0 -1 0 ] 0 1 1 } }","Base Material Dir : Root folder where your Godot map materials are located. If unspecified it falls back on Base Texture Dir.","Base Texture Dir : Root folder where your Godot map textures are located","But if that's the case, how does FuncGodot know what file to use?","Default Material : The default material that FuncGodot builds your map's materials from","Default Material Albedo Uniform : If the default material is a ShaderMaterial rather than StandardMaterial3D, this is the shader uniform that provides the albedo texture","Default texture","FuncGodot Map Settings has several properties that help define and apply textures to your meshes on build:","FuncGodot's first step is to search the Base Material Dir for a prebuilt material as defined by the brush face's texture name in the format defined by Material File Extension.","FuncGodotMapSettings properties","If it does not find the Texture2D, then it will use the default_texture.png found in the addons/func_godot/textures/ folder.","If it does not find this prebuilt material, it will search the Base Texture Dir for the Texture2D resource by the brush face's texture name using any one of the extensions defined by Texture File Extensions. If it finds the Texture2D, it will create a copy of the Default Material and apply the Texture2D as the duplicated material's albedo.","If you take a look at a .map file, you'll see that it's just a text file describing the makeup of your map and doesn't actually store any other data, including texture images. Let's look at this example of a Solid Entity in a map file:","Material File Extension : Format for custom texture materials, can be .tres, .res or .material","NOTE: If a Solid Entity definition's Build Visuals property is set to false, no materials will be generated.","Once the material generation is completed, you can optionally have FuncGodot save generated materials so they can be reused by multiple FuncGodotMaps. Otherwise each FuncGodotMap will have its own unique material for each texture used in the map.","Save Generated Materials : Save automatically generated materials to disk, allowing reuse across multiple FuncGodot maps. FuncGodot will skip saving materials using clip, skip, or missing textures. NOTE: once saved, materials will no longer inherit from the Default Material_. If you want to make any changes to their settings you will have to either do so manually or delete the materials and allow FuncGodot to rebuild and resave them._","Solid Entity Example","Texture File Extensions : The extensions to search for if no matching material is found","Texture Wads : Array of WAD resources to search through","This is a func_detail entity from the default FuncGodot.fgd. As you can see, the map file structure is pretty straight-forward. This particular map uses the Valve 220 format, having additional options for UV mapping. Each line in a brush definition describes a face on the brush, and within that you can see that our texture is defined as just its location relative to the game's texture folder or map's WAD file."]},{"l":"Automatic PBR / ORM Generation","p":["You may have noticed that we skipped over a few settings before, all of them with the suffix \"Map Pattern\". When using a Default Material extending from BaseMaterial3D, FuncGodot has the ability to automatically generate PBR and ORM materials on build. Each of the \"Map Pattern\" properties tell FuncGodot's Texture Loader how to find each texture map for our material.","What's with all the %s everywhere?","It's a placeholder token that gets replaced during texture loading. Each pattern requires two %s tokens. The first token is for the texture's name as it appears in the map file. The second token is for the file extension; this is replaced as the Texture Loader cycles through the Map Settings' Texture File Extensions searching for your texture. So if Texture Loader is looking for the normal map of a texture entry named \"rock\" and our Map Settings' Normal Map Pattern is \"%s_normal.%s\" and it is currently checking for the \"png\" Texture File Extension, then it will be looking to see if the texture resource \"rock_normal.png\" exists, and if so it will be applied to the Map Settings' Default Material if it is a StandardMaterial3D.","FuncGodot will look for PBR / ORM texture maps in both the same folder as the texture applied in the map file, or it will look in a subfolder with the same name. As an example: a brush is applied with the \"textures/rock\" texture in TrenchBroom, FuncGodot will first look for \"textures/rock_normal.png\" and then check \"textures/rock/rock_normal.png\"."]},{"l":"Shader Material Uniform Mapping","p":["So you've decided to use a ShaderMaterial with a custom GDShader. FuncGodot has the ability to automatically assign textures to your shader uniforms when generating ShaderMaterials on build through the use of the use of Map Settings' shader_material_uniform_map_patterns Dictionary.","The dictionary is fairly straightforward: add your shader's uniforms as the dictionary's keys, while your values are the naming patterns for that uniform's textures. Unlike Automatic PBR generation, you only use one placeholder token, used for the base texture's name. An example of an entry would be a key \"normal_map\" paired with a value \"%s_n\"; if FuncGodot finds a texture named \"textures/brick.png\", it will then search for \"textures/brick_n.png\" and assign it to the generated ShaderMaterial's \"normal_map\" uniform.","NOTE: When using PBR materials with TrenchBroom, remember that you can add Texture Exclusion Patterns to the TrenchBroom Game Config to hide specific textures in the editor."]},{"l":"Clip and Skip Textures"},{"l":"Mapping for Quake Godot","p":["We started off this manual with the point that FuncGodot is not a BSP compiler. If we map like we do in traditional Quake mapping...","... we don't get the same result.","Instead we need to change our approach.","For those not familiar with traditional Quake mapping, the finished MAP gets compiled into a BSP file to be read by the engine. The compiling process calculates visibility between all of the rooms of your map and removes all faces that won't be viewed due to being outside the map. That means maps must be sealed completely, but you're also allowed to be lazy with brush texturing since if a face is \"outside\" the map it will get culled.","With Godot we need to think of these brushes as what they'll become in-engine: composited MeshInstance3Ds and CollisionShape3Ds. If we want to achieve the culled result on the left, we'll need to change the way we do things on the right."]},{"l":"Skip It","p":["Clip texture Skip texture","The Clip and Skip textures are arguably our most important textures when mapping for Godot. You can assign any texture's name to the Clip and Skip properties of the FuncGodotMapSettings resource. But what do they do?","The Clip texture will remove any face textured with it from the generated MeshInstance3D. The Skip texture behaves the same way if the Solid Entity's Collision Type is set to Convex. However, if the Solid Entity's Collision Type is set to Concave, this also removes the Skip textured faces from the generated CollisionPolygonShape3D.","Just keep in mind the general rule of thumb: if you want your entities to collide with the brush, use Clip...","... and if you want them to pass through, use Skip (with Concave collision)."]},{"l":"The Origin Texture","p":["Origin texture","In Half-Life mapping, some entities like rotating doors require an origin brush to determine where the hinge should be. FuncGodot provides a means to emulate this behavior using a special origin texture. Just like Clip and Skip, the Origin texture is assigned by the FuncGodotMapSettings resource.","To use it, first you must set your Solid Entity class resource origin type to BRUSH. Then in your map editor, create your brush entity as you normally would. Once you've done that, add an additional brush to your entity, move it to where you want the entity's pivot point to be, and texture it with the Origin texture.","Once you build the map in Godot, your entity should now have its pivot point set to the center of where the Origin brush was in the map file, and the Origin brush is removed.","One last note: if you don't create an Origin brush on a Solid Entity with the BRUSH origin type, it will fall back to using the BOUNDS_CENTER origin type."]},{"l":"WAD Files","p":["FuncGodot provides the option to use Texture WAD files for your map materials. It's generally not recommended if it can be helped, but support for loose texture images varies from map editor to map editor. FuncGodot supports both the Quake WAD2 format and the Half-Life WAD3 format.","To use a WAD file with your FuncGodotMap just add your imported WAD resource to the map node's Texture Wads array.","The neat thing about how FuncGodot handles map textures is that we can technically use a completely different folder in TrenchBroom and even different image formats than the location and formats we keep them in Godot. This can be useful for advanced users, but you may want to just keep all of your textures unified."]},{"l":"Why Are My Textures Blurry!?","p":["You may be encountering at least one of two issues: texture compression and / or material sampling settings.","Make sure your texture resource is set to either Lossless or VRAM uncompressed. Please refer to the Godot documentation on texture compression.","If you had created your own materials for your map, check that the material's or texture's Sampling Filter is set to Nearest Mipmap. Please refer to the Godot documentation on texture filtering."]}],[{"l":"TrenchBroom Resources","p":["Array[Dictionary]","Array[Resource]","Array[String]","Available map formats when creating a new map in TrenchBroom. The order of elements in the array is the order TrenchBroom will list the available formats. The initialmap key value is optional.","Bool","Brush Tags","Brushface Tags","Button to export / update this game's configuration in the TrenchBroom Game Config Folder.","Compatibility","Default scale of textures on new brushes and when UV scale is reset.","Default Uv Scale","Defines a game in TrenchBroom to express a set of entity definitions and editor behaviors.","Description","Entities","Entity Scale","Export File","Face Attributes","Fgd File","FGD resource to include with this game. If using multiple FGD resources, this should be the master FGD that contains them in the base_fgd_files resource array.","FuncGodotFGDFile","Game Config Version","Game configuration format compatible with the version of TrenchBroom being used. Only change if you're having Game Config errors upon starting TrenchBroom.","Game Name","GameConfigVersion","Icon","Icon for TrenchBroom's game list.","Map Formats","Name of the game in TrenchBroom's game list.","Palette Path","Palette path relative to your Game Path. Only needed for Quake WAD2 files. Half-Life WAD3 files contain the palettes within the texture information.","Path to top level textures folder relative to the game path.","Property","Scale expression that modifies the default display scale of entities in TrenchBroom. See the TrenchBroom Documentation for more information.","String","Tags","Texture Exclusion Patterns","Texture2D","Textures","Textures Root Folder","Textures with names matching these patterns will be hidden from TrenchBroom. Useful for hiding PBR maps and animation frames.","TrenchBroom has the strongest support from FuncGodot, and as such is the recommended map editor for use with the plugin. FuncGodot has optional support for TrenchBroom Layers and Groups, and TrenchBroom supports multiple bit flag key value pairs. To aid with TrenchBroom support, FuncGodot offers two different resources.","TrenchBroomTag resources that apply to brush entities.","TrenchBroomTag resources that apply to brush faces.","Type","Vector2"]},{"l":"TrenchBroomTag","p":["A string that filters which flag, param, or classname to use. * can be used as a wildcard to include multiple options. For example, a Tag Pattern of \"trigger_*\" with a TagMatchType Classname will apply this tag to all brush entities whose classnames begin with \"trigger_\".","A string that filters which textures recieve these attributes. Only used with a TagMatchType of Texture.","Array[String]","Description","Determines how the tag is matched. If set to TagMatchType.TEXTURE, the tag applies to any brush face with a texture matching the Texture Name. If set to TagMatchType.CLASSNAME, the tag applies to any brush entity with a classname matching the Tag Pattern.","Name to define this tag. Not used as the matching pattern.","Pattern matching tags to enable a number of features in TrenchBroom, including display appearance, menu filtering options, and keyboard shortcuts. This resource gets added to the TrenchBroomGameConfig resource. It does not affect appearance or functionality in Godot. See the TrenchBroom Documentation on Tags under the Game Configuration section for more information.","Property","String","Tag Attributes","Tag Match Type","Tag Name","Tag Pattern","TagMatchType","Texture Name","The attributes applied to matching faces or brush entities. Only \"_transparent\" is supported in TrenchBroom, which makes matching faces or brush entities transparent.","Type"]}],[{"l":"Why Not Worldspawn?"},{"l":"First things first... What IS Worldspawn?","p":["As mentioned before, FuncGodot comes with a set of example Entity Definitions, including one for the worldspawn class that comes built-in to every Quake map file. But what is worldspawn?","Every Quake map file contains a list of entities containing a set of key value pairs. Some optionally include brush definitions. In Quake, the entity's classname is also the spawn function that is called upon map start. The very first entity that needs to load is the world, so entity 0 is always worldspawn. There can also only ever be one Worldspawn in a Quake map (with one weird exception I'll mention later).","Simply put, Worldspawn is just another entity. It's not even a Solid Entity by default. It needs to be defined in your FGD just like any other entity, too, or else it will revert to a simple Node3D with a mesh and no collision. The only special behavior Worldspawn has is that its position will always be the FuncGodotMap's position, unlike other Solid Entities.","The example Worldspawn entity is defined as a Solid Class StaticBody3D with convex collision, and the general understanding is that it's a built in mechanic of FuncGodot. Some of you need to have your stage geometry cut up for occlusion or per-collider purposes. In Tim's game They Came From Dimension X, worldspawn was changed into a WorldEnvironment that instantiates a LightmapGI while also handling default music playback and other map-wide settings. You might think of a completely different use case for it.","NOTE: Setting Worldspawn as a Point Class may have undefined side effects due to being able to place a second Worldspawn in your map. It is recommended that any Worldspawn definition be a Solid Class.","So why not Worldspawn?"]},{"l":"Occlusion Culling","p":["Performance on larger or heavily populated maps mostly. Godot culls objects by the VisualInstance; in the case of our maps, this means mesh by mesh. In order to get better performance we'll need to split our map up into smaller chunks.","Meshes are generated on a per-entity basis: every brush in a Solid Entity is merged into a single mesh. Since Worldspawn is an entity, any brush that is a part of Worldspawn gets merged into the same mesh. If we want to split up our mesh, we need to split our Worldspawn into separate entities.","Remember: FuncGodot is not a BSP compiler. This means mapping for Godot like you're mapping for Quake is counterproductive. Instead, make sure you give some thought to how you'll split up your geometry entities, and how the brush vertices meet with each other. In exchange for full automation, FuncGodot instead gives you full control."]},{"l":"Surface \"Materials\"","p":["A common question a lot of Godot devs have is how do I get the texture of the surface my character is stepping on or shooting? and the answer is... you don't! Well, the short answer anyway. Since Godot's CollisionObjects are completely separate from the MeshInstance3Ds, there's no real good performant way to actually do it surface by surface. Any possible solutions that involve getting the stage mesh's texture on a particular face are just not worth it. But why work against the engine when you can work with it?","If we can control how our stage geometry is split up, we can also provide that stage geometry with key value properties, including one that supplies a Material Type that can easily be passed to any character stepping on or shooting it. This is something that can't be done with a singular Worldspawn entity."]},{"l":"How Do I Live Without Worldspawn?","p":["You'll want to create a Solid Class entity that matches the Worldspawn entity definition. It's recommended that you change the Spawn Type to ENTITY though. Feel free to also add any Class Properties you feel would benefit your game's design. The world geometry solid class entity used in Tim's games is typically called func_geo. He never shuts up about it."]},{"l":"A World Alongside Worldspawn","p":["It would also help to create your own new worldspawn entity definition that doesn't build visuals or collision, so that you can more easily tell if that stage geometry was given its own func_geo or was accidentally left as worldspawn. Keep in mind that a Quake map file's first entity will always be worldspawn, and that all map editors will only allow you to have one that they make automatically.","With that in mind... why not a WorldEnvironment? Let's take a look at an example of how you might repurpose a Worldspawn for one.","In TrenchBroom we can have our `worldspawn` settings set up like this in our FGD. We're assuming you know how this is done by now, but if not please go back and reread the section on Entities near the beginning of the manual.","Then in Godot, when the map is built and the Worldspawn's func_godot_properties dictionary is set, it runs the _func_godot_apply_properties(props) method.","It doesn't stop there, by the way. You may have noticed a number of key value pairs in our TrenchBroom entity: lit_bounces, lit_denoiser, etc... Instead of manually creating the lightmap for each map, we can have our Worldspawn entity programmatically create and modify the LightmapGI node any time the map is built. To do this, we'll use the _func_godot_build_complete() method, automatically called as a deferred call at the end of the build process.","That's right: during the build process you can have your entities' properties affect other entities or nodes outside of the FuncGodotMap node. This is somewhat advanced Godot scripting, as you do need to understand a bit more about when objects will exist in the SceneTree, but it's an extremely powerful tool at your disposal.","Hopefully this little essay asking you to question the role of Worldspawn has gotten you thinking a bit more outside the box in regards to what you can do with FuncGodot. Be sure to join our Discord community and let us know what you did with your Worldspawn!"]}]]